NAME
    Shell::Cmd - run shell commands with enhanced support

SYNOPSIS
       use Shell::Cmd;

       $obj = new Shell::Cmd;

DESCRIPTION
    A very common use of perl is to act as a wrapper around shell commands
    where perl is used to prepare the shell commands, execute them, and deal
    with the resulting output. Even where the bulk of the work is actually
    done in the perl script, creating small shell scripts within it to do
    some portion of the task is common.

    In the simplest form, running shell commands can be done very simply
    using the "system()" call, backticks, or several other ways, but I
    usually find myself wanting to do a bit (and sometimes a lot) more,
    especially when I am writing a long-term script that I want to be
    robust. In these cases, I frequently ended up writing a subroutine to
    run the shell command(s) for me with added functionality.

    This module is designed to take a list of shell commands and
    automatically turn them into a shell script (using only basic shell
    commands) which adds some common desirable functionality including:

    Handle STDOUT/STDERR
        Commonly, I want to treat STDOUT and STDERR in some way. I may want
        to keep one or both of them, or discard one or both of them, or
        merge them.

    Command echoing
        A common option I want to set is command echoing where the commands
        I run are echoed as they are run. I want to be able to easily turn
        this on or off (typically with a command line option in the calling
        script).

    Dry-run
        Another common option is to create a dry-run environment where the
        shell commands may be printed, but not actually run. Again, I want
        to be able to turn this on and off easily.

    Error trapping
        Even though I may combine a number of shell commands into a single
        script (so that it all runs in one shell), I still want to have
        built in error trapping at a per-command basis. I want to take a
        series of commands and know exactly which one failed.

        I also want to be able to control what happens to commands that are
        listed after a failed command. I may want to ignore an error and
        continue to run the remaining commands. I may want to simply exit.
        Or I may want to echo, but not run the remaining commands so that I
        can see what didn't get completed.

    Shell environment
        I sometimes want to set up some environment for the script such as
        what directory it will be run in and what environment variables
        should be set in advance.

    Command alternates
        Sometimes, especially if you are running the script on multiple
        platforms, you may not know which command you should use. You can of
        course generate a platform specific script, but an alternative is to
        specify alternate commands. If ANY of those commands succeed, then
        that portion of the script succeeds.

    Command retrying
        Occasionally you have a command that may fail, but on retrying, it
        will succeed. This is especially true when some effect from a
        previous command takes some amount of time to actually go into
        effect. By allowing a certain number of retries, you can often work
        around this situation.

    Remote execution
        Sometimes you want to run the commands locally. Other times, you
        want to run it remotely using ssh. When running remotely, you may
        want to run the same script on multiple hosts.

    SSH handling
        When running on multiple hosts using SSH, sometimes you need to run
        the script serially (i.e. one host at a time), but other times, it
        would be nice to run it in parallel to speed up execution. When
        running in parallel, you should be able specify how many instances
        to run at at time.

    Quoting and special characters
        Since shell commands often have quotes, dollar signs, and other
        special characters, this module can handle that for you by properly
        escaping them as necessary.

    This module is designed to run multiple commands in a single shell,
    wrapping them in very simple, standard shell commands to automatically
    add all of this functionality.

METHODS
    new
           $obj = new Shell::Cmd;

        This creates a new object containing commands.

    version
           $vers = $obj->version();

        Returns the version of this module.

    cmd
           $err=$obj->cmd($cmd [,\%options], $cmd [,\%options], ...);

        This is used to add one or more commands to the list of commands
        that will be executed.

        Here, each $cmd is a string containing a command, or a listref where
        each element in the list is a command.

        In the listref form, the list of commands are alternates to try
        until one succeeds, and the command only fails if all of the
        alternates fail. This might be used to specify different paths to an
        executable, or different executables that perform essentially the
        same function, but which might not all be available on all
        platforms.

        For example, if you wanted to run a command to get the contents of a
        web site, and you didn't know which of curl, wget, or lftp were
        available, you might use something like this:

           $err = $obj->cmd([ "wget $URL", "curl $URL", "lftp $URL"]);

        and in this case, it would try wget, and if that failed, it would
        try curl, and if that failed, it would try lftp. The command will
        only fail if all three alternates fail.

        Each command (or list of alternates) can have options passed in.
        These options apply only to this command (or list), and are
        described in the "PER-COMMAND OPTIONS" section below.

        All of the commands stored in $obj will be run in a single shell, so
        it is fine to gather information in one command and store it in a
        shell variable for use in a later command. Also, it is not necessary
        (or desirable) to include a trailing semi-colon on the command as
        these will be added automatically as needed.

        An error is returned if any of the arguments are invalid.

        It should be noted that no attempt is made to see if the syntax of
        the shell command is correct. That is beyond the scope of this
        module.

        If only simple lists of commands are used, handling them is
        relatively straightforward, but trying to include commands that
        affect the flow of the script (such as "while...done", "if...else",
        and the like) then handling can be much more complicated. Refer to
        the "FLOW COMMANDS" section below.

    run
           $obj->run();

        This prepares a shell script based on the commands and options
        entered and runs it as appropriate. There are several different ways
        in which the commands can be run, and these are described in the
        options method below. The most important option is the mode option
        which sets the mode which determines the form of the script, and how
        it is run.

        If $obj is in 'run' mode, the method is called as:

           $err = $obj->run();

        In this mode, the script is run, and output is sent directly to
        STDOUT and STDERR as appropriate for the options specified. In
        essence, this generates a script and runs it with the "system()"
        call.

        If a temporary script file is used, but it cannot be written, $err
        will be -2. Otherwise, the return value of the method is the exit
        code of the script (which is the exit code of the first failing
        command).

        If $obj is in 'dry-run' mode, the method is called as:

           $script = $obj->run();

        In this mode, the commands are not actually executed. Instead, the
        script is built and returned. The form of the script is determined
        by the script option described below.

        If $obj is in 'script' mode, the output from the commands are kept
        for further analysis. The method should be called as:

           $err = $obj->run();

        and then use the $obj->output(...) method to examine the resulting
        output.

    ssh
           $obj->ssh(@hosts);

        This behaves similar to the run method except it will run the
        commands on each host in @hosts using ssh.

        In 'dry-run' mode, the call is:

           @script = $obj->ssh(@hosts);

        In 'run' mode, the call is:

           @err = $obj->ssh(@hosts);

        In 'script' mode, the call is:

           $obj->ssh(@hosts);

        Note that when running in parallel in 'run' mode, the output that is
        printed to the terminal will be a mix of the output from each of the
        hosts the commands are being run on.

        If the tmp_script option is set but the file cannot be written, the
        return value in both cases will be (-2). If the file cannot be
        copied to a host, then the return value for that host will be -3.

    output
           @out = $obj->output(%options);
           %out = $obj->output(%options);

        This will return the output produced by running the commands in
        'script' mode.

        The %options argument is described below in the OUTPUT OPTIONS
        section.

    flush
           $obj->flush( [@opts] );

        If @opts is not given, it removes all the data stored in the object,
        resetting it to a clean object. If @opts is given, you can clear
        specific parts of the object. Any of the following options can be
        given:

           commands   : clears all commands and their options
           dire       : clears the directory
           env        : clears the environment
           opts       : clears all options
           out        : clears the output from running the command
                        in 'script' mode

    dire
           $err = $obj->dire($dire);

        This method is used to set the dire option. For a description,
        please see the entry in "GLOBAL OPTIONS" below.

        You can also check the value that is set using:

           $dire = $obj->dire();

    mode
           $err = $obj->mode($mode);

        This method is used to set the mode option. For a description,
        please see the entry in "GLOBAL OPTIONS" below.

        You can also check the value that is set using:

           $mode = $obj->mode();

    env
           $obj->env(VAR, VAL, VAR, VAL, ...);

        This can be called any number of times to set some environment
        variables. If $val is undef, the environment variable will be
        explicitly unset.

        You can also query the environment variables with:

           @env = $obj->env();

        It will return a list of ( VAR VAL VAR VAL ... ).

    options
           $err = $obj->options(%options);

        This can be used to set some options about what will be done when
        the commands are run.

        The hash is of the form:

           %options = ( OPTION => VALUE,
                        OPTION => VALUE, ...)

        The options are defined in the "GLOBAL OPTIONS" section below.

GLOBAL OPTIONS
    The following global options exist can can be set using the options
    method:

    mode
        The mode option determines how the commands will be handled by the
        run method. The following values are available.

           dry-run
           run
           script

        The default option is to use 'run' mode.

        The 'dry-run' mode will simply return the script that would have
        been run, but it doesn't actually run it.

        The 'run' mode is the standard way to run commands in an interactive
        setting. It will run the commands in real-time and allow you to
        watch STDOUT and/or STDERR (depending on the options you choose) as
        they run.

        The 'script' mode is more appropriate for running in an unattended
        script. It gathers the output and post-processes it allowing for
        more useful handling of the output. For example, you could discard
        the output from commands that succeed and keep only the output for
        the one that failed.

        The mode option can also be set using the mode method.

    tmp_script, tmp_script_keep
        The tmp_script option is used to specify a temporary script name.

        The script that is generated by this module may exceed the length of
        a string that can be passed directly to a shell. In order to avoid
        this problem, the script can be stored in a temporary script file
        (set with the tmp_script option) which will be executed.

        Once execution is complete, the temporary script file will be
        removed unless the tmp_script_keep option is set.

    ssh_script, ssh_script_keep
        These are related to the tmp_script and tmp_script_keep options. If
        tmp_script is created, then when the ssh method is used to run the
        script remotely, it is copied to the remote host (via. scp) to a
        temporary location (given by ssh_script). The remote script is then
        removed (unless ssh_script_keep is passed in).

        If tmp_script is set but ssh_script is NOT, ssh_script defaults to
        the same value as tmp_script.

        ssh_script_keep defaults to 0, even if tmp_script_keep is set.

    dire
        The dire option is use to specify the directory where all of the the
        commands should be run. This can be overridden on a per-command
        basis using the cmd method, but all commands not specifically set
        will run in this directory.

        This does NOT check the existence of the directory until the
        commands are actually run since the commands may be run via. ssh.

        The dire option can also be set using the dire method.

    output
        The output option can be one of the following:

           both
           merged
           stdout
           stderr
           quiet

        In the 'run' mode, these determine what output will be displayed.

        It can display only STDOUT, only STDERR, or both, or both can be
        discarded with the 'quiet' option. The default is to include 'both'.
        The 'merged' option is used to display both but merge STDERR into
        STDOUT (using a "2>&1" redirection).

        The default in both cases is 'both'.

        In the 'script' mode, this specifies which output is stored in the
        object. Output that is stored is available (using the output method)
        to be examined. If the output is discarded, it will not be available
        for further examination.

    script
        The script option is used only in dry-run mode.

        When commands are run in dry-run mode, a script is produced. The
        form of that script is controlled by this option. The value may be
        any of:

           run
           script
           simple

        If the value is 'run' (which is the default), the script produced
        will be exactly the script produced in the 'run' mode. If the value
        is 'script', the script will be the script produced in 'script'
        mode.

        If the value is 'simple', the script will simply be the list of
        commands with the minimum necessary additions to handle directory
        and environment variables. No additional scripting will be added to
        do error checking or add other functionality.

    echo
        The 'echo' option is used in 'run' mode. With it, you can choose
        whether or not the commands should be displayed before they are run.

        The values are:

           echo
           noecho
           failed

        With 'echo' and 'noecho', commands will be displayed or NOT
        displayed respectively.

        If the value is 'failed', a command that failed will be displayed.
        Since it has already run, the command will be echoed after execution
        rather than before.

    failure
        When a command fails, there are several alternatives that can be
        done. Values for this option are:

           exit
           display
           continue

        The default is 'exit'. With this option, the shell will stop
        executing commands once one has failed. The exit code is the code
        from the failed command. When running in script mode, no information
        about remaining commands is returned.

        With the 'display' option, the simple script is displayed (in 'run'
        mode) and the point of failure is marked. The exit code is the code
        from the failed command.

        With the 'continue' option, remaining command are executed, but the
        overall exit values is still set to point at the first failed
        command.

    ssh_num
        When running a command on multiple hosts via SSH, it is possible to
        run them serially (one at a time) or in parallel.

        This option can be set to a number 0 or more. If the number is 1,
        then only a single ssh connection will be made at a time so the
        hosts will all be contacted serially.

        If the option is set to 0, all of the hosts will be run
        simultaneously.

        If the option is set to N, N simultaneous connections will be
        allowed.

    ssh_sleep
        When running a command on multiple hosts via SSH, it is sometimes
        desirable to stagger them slightly so multiple copies are running at
        the same time, but not at EXACTLY the same time.

        If this option is set to 0 (the default), all of the commands will
        be run with no delay. If it is set to the value N, commands will
        sleep a random amount of time (from 0 to N seconds) before running.

    ssh:XXX
        When running a command on a remote host via. ssh, the Net::OpenSSH
        module is used.

        Every option that can be passed to the 'new' method can be set here.
        For example, if you want to call Net::OpenSSH as:

           $ssh = Net::OpenSSH->new($host, user => $user_name);

        just set the option:

           ssh:user = $user_name

PER-COMMAND OPTIONS
    The following options exists that can be applied to individual commands.
    They can be set in the cmd method.

    dire
        The dire option refers to the directory which this single command
        should be executed in. The value of the option is the directory.

        This will basically wrap a command in:

           CURR_DIR=`pwd`
           cd $dire
           COMMAND
           cd $CURR_DIR

    noredir
        If the noredir option is included, no command line redirection is
        done for this command. Most commands automatically redirect STDOUT
        and STDERR based on the output and f-output global options.

        If the command explicitly sends these to somewhere (such as a log
        file or temporary file), use the noredir option so automatic
        redirection is not done.

    retry, sleep
        The retry and sleep options can be used to retry a command.

        Sometimes, a command may fail but running it a second time can
        succeed. Often, a command completes, but for various reasons, it
        takes a certain amount of time after the command completes for the
        full results to take effect. A later command might be run before
        those results have taken effect, but rerunning it a few seconds
        later would succeed.

        With the retry option, you can retry a command. The value of the
        retry option should be an integer (N). If N is greater than 1, the
        command will be run up to N times total. Any other value of N will
        be ignored, and the command will run only a single time.

        There can be an optional sleep time between running the command. The
        optional sleep option (which should also be an integer) sets the
        number of seconds between retries. If the value is 0, or not an
        integer, there will be no delay between retries.

        This command will be marked as failed only if all of the retries
        fail.

        You cannot retry a flow command.

    check
        Sometimes, a command is written such that the exit code does not
        accurately reflect whether the command failed or not. It may produce
        a zero exit code but still have failed, or it may have succeeded but
        still produce an error code.

        In these cases, you can supply a command with this option which will
        check the result of the command and set the error flag
        appropriately.

        If the command succeeded, the error flag should be set to zero. If
        it failed, it should be set to something non-zero.

        If this is given for a command which has alternatives, it will be
        run after every alternative.

    label
        Each command can have a label attached to it which will allow you to
        refer to that command by the label. This is useful in analyzing the
        output.

FLOW COMMANDS
    When simple shell commands are given, there is no ambiguity about how to
    treat each, so handling them is relatively simple. Simple commands are
    fully supported, and all of the functionality described above can be
    added.

    However, when flow commands are included, they must be handled in a
    different way in order to deal with them properly. This is because the
    added functionality is done by wrapping each command with some enclosing
    shell structure to add it. It is very easy to wrap regular shell
    commands in some enclosing structure. For example, it is easy to turn:

       mycommand arg1 arg2

    into

       if [ SOME_CONDITION ]; then
          DO_SOMETHING
          mycommand arg1 arg2
          DO_SOMETHING
       fi

    but you can't wrap the commands of an "if/else/fi" block or a
    "while/done" block. As a result, each type of flow must be considered
    carefully.

    Currently, the supported flow commands are:

    "if...elsif...else...fi"
        In order to recognize them, the commands will be partially parsed,
        and they must be of the forms:

           if ... ; then
           elif ... ; then
           else
           fi

        where '...' may be any string. In other words, the first line must
        start with if, followed by whitespace, and end with a ';' followed
        by optional whitespace, followed by 'then'.

        The alternate formatting of:

           if ...
           then
           fi

        is not supported.

    "while...done"
    "until...done"
    "for...done"
        The commands must be of the form:

           while ... ; do
           until ... ; do
           for ... ;do
           done

    At some point, the "select" and "case" structures may be supported, but
    this in not yet available.

OUTPUT OPTIONS
    When commands are run in the 'script' mode, the output is stored in the
    object.

    To access the output, use one of the following calls to the output
    method:

       @out = $obj->output(%options);
       %out = $obj->output(%options);

    If the commands were run on the current host with the run method, the
    first call is used. The output will always be returned as a list.

    If the commands were run on multiple hosts using the ssh method, the
    second call is typically used. This will return a hash:

       %out = { HOST => [@out] }

    where "HOST" is the name of the host, and @out is the output that you
    have requested.

    If you want to look only at the output on a single host (see the host
    option described next), the output will be returned as a list rather
    than a hash.

    The output method will return selected portions of the output in the
    format specified by the options as described below.

    host
        If the commands are run using the ssh method on multiple hosts, then
        you can specify which host or hosts you are interested in using this
        option.

        The value of the host option can be a scalar (the name of the single
        host you want to examine) or a list (the names of multiple hosts you
        want to examine). If the option is not given, you will look at the
        output from all hosts.

        If the value is specified as a scalar, the output will be returned
        as a list. If the value is a list (even if it only has a single
        element), the output will be returned as a hash.

    command
        # =item f-output

        # The f-output option can be one of the following:

        # both # merged # stdout # stderr # quiet

        # and is only used in 'script' mode.

        # In 'script' mode, all of the output is gathered and analyzed after
        # the commands are run, so the output can be tailored to whether a #
        command completed successfully or failed.

        # The 'output' option controls what output is returned for commands
        that # completed successfully, and the 'f-output' option controls
        the output # given for a failed command. Note that if a command has
        multiple # alternatives, and one of them succeeds, the command is
        treated as # succeeding, and the output for all alternates (even the
        individual ones # that fail) will follow the rules of 'output'
        rather than 'f-output'.

        # It should be noted that since the command runs fully before it can
        be # seen whether it failed or not, STDOUT/STDERR will either be
        separate # or merged based on the first option. If the first option
        is 'both', # 'stdout, or 'stderr', they will be separate, and the
        'f-merged' option # is not supported (it will be replaced by
        'f-both'). If the first # option is 'merged', then the 'f-both',
        'f-stdout', and 'f-stderr' # options are not supported and will be
        replaced by 'f-merged'.

        # The default to these are 'both' and 'f-both'.

KNOWN PROBLEMS
    Minimal support for complex scripts
        These methods work best for simple lists of commands. Using simple
        command flow (<if...then...else>, etc.) is allowed, but must be used
        carefully.

LICENSE
    This script is free software; you can redistribute it and/or modify it
    under the same terms as Perl itself.

AUTHOR
    Sullivan Beck (sbeck@cpan.org)

